package {	import flash.utils.*;	import flash.display.Sprite;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.Font;	public class YugoTxt extends Sprite {		var interval:uint;		var waitChar:String;		var charSpeed:uint;		var moveFix:uint;		var moveRange:uint;		var moveTrigger:uint;		/////////		var str:String;		var randomList:Array;		var textCount:uint;		var fixLength:uint;		var fixStr:String;		var a:uint;		/////		var cMin:uint;		var cMax:uint;		var listener:Array;		var c:uint;		/////		var randomTypo;		var end_textCount;		var end_charMotion;		var typoText;		var previous_instance;		//		var n:uint;		var myTime:uint;		var txtInt:uint;		var myTxt:Array;		public var lab:TextField  // REQUESTED		public var myTextFormat:TextFormat // REQUESTED		public function YugoTxt():void {			interval = 2000;			//trgt = typoText;			//titArray = _global.titles;			waitChar = "-";			moveFix = 10;			moveRange = 15;			moveTrigger = 12;			charSpeed = 2;			///////			cMin = 33;			cMax = 96;			listener = [];// DON'T TOUCH THIS // START //			myTextFormat = new TextFormat();			myTextFormat.size = 48;			myTextFormat.color = 0x000000;			myTextFormat.align = "center";			//			lab = new TextField();			lab.selectable = false;			setDefaultFont()			addChild(lab)			// DEBUG START			//startReader("passioni elettroniche per cuori vettorializzati, formule binarie per ridurre la complessità e scannerizzare gli stimoli ", 1000)			// DEBUG END// DON'T TOUCH THIS // END //		}		public function setDefaultFont():void { // REQUESTED FUNCTION			myTextFormat.font = Font.enumerateFonts(false)[0].fontName;			lab.embedFonts = true			lab.setTextFormat(myTextFormat);			lab.defaultTextFormat = myTextFormat		}		public function startReader(txt:String, tapValue:uint):void { // REQUESTED FUNCTION			myTxt = txt.split(" ");			myTime = tapValue;			n = 0;			myPlay();		}		public function myPlay():void { // REQUESTED FUNCTION			clearInterval(this.txtInt);			clearInterval(c);			if (this.myTxt.length>0) {				waitChar = "-";				moveFix = 10;				moveRange = 15;				moveTrigger = 12;				charSpeed = 2;				setText(waitChar, charSpeed, moveFix, moveRange, moveTrigger);			}		}		public function myStop():void { // REQUESTED FUNCTION			clearInterval(this.txtInt);			clearInterval(c);		}		public function myRewind():void { // REQUESTED FUNCTION			n = 0;		}		function leggi():void {			clearInterval(this.txtInt);			clearInterval(c);			if (this.myTxt.length>0) {				waitChar = "-";				moveFix = 10;				moveRange = 15;				moveTrigger = 12;				charSpeed = 2;				//this.txtInt = setInterval(setText, interval, trgt, waitChar, charSpeed, moveFix, moveRange, moveTrigger);				setText(waitChar, charSpeed, moveFix, moveRange, moveTrigger);			}		}		function setText(waitChar:String, charSpeed:uint, moveFix:uint, moveRange:uint, moveTrigger:uint) {			str = myTxt[n].toUpperCase();			if (str != "") {				randomList = [];				textCount = 0;				fixLength = 0;				fixStr = "";				for (a=0; a<=str.length-1; a++) {					if (str.charAt(a) != " ") {						randomList[a] = (moveFix+Math.round(Math.random()*moveRange))*(Math.round(Math.random())-0.500000)*2;					} else {						randomList[a] = 0;					}				}				this.txtInt = setInterval(randomMotion, myTime/10);				//trgt.onEnterFrame = this.randomMotion;			}			n++;			if (n>=myTxt.length) {				n = 0;			}		}		function randomMotion() {			lab.text = fixStr;			//trgt.lettore(fixStr, fixStr, fixStr);			var tmp = fixStr;			//this.text = fixStr;			end_charMotion = true;			for (a=fixLength; a<=textCount; a++) {				if (randomList[a] != 0 && randomList[a] != undefined) {					end_charMotion = false;					if (Math.abs(randomList[a])<=moveTrigger) {						var charcode = Math.min(Math.max(str.charCodeAt(a)+randomList[a], cMin), cMax);						tmp = tmp+String.fromCharCode(charcode);								lab.text = tmp;			//trgt.lettore(tmp, tmp, fixStr);						//this.text = this.text+String.fromCharCode(charcode);					} else {						tmp = tmp+waitChar;								lab.text = fixStr;			//trgt.lettore(tmp, tmp, fixStr);						//this.text = this.text+waitChar;					}					if (randomList[a]>0) {						randomList[a] = randomList[a]-1;					} else {						randomList[a] = randomList[a]+1;					}				} else {					if (fixLength == a-1) {						fixLength = a;						fixStr = str.substring(0, fixLength);					}					tmp = tmp+str.charAt(a);					lab.text = tmp;					//trgt.lettore(tmp, tmp, fixStr);					//this.text = this.text+str.charAt(a);				}			}			if (textCount<=str.length) {				textCount = textCount+charSpeed;			} else {				end_textCount = true;			}			if (end_charMotion && end_textCount) {				stopAction();			}		}		function stopAction() {			clearInterval(this.txtInt);			c = setInterval(leggi, myTime);			// delete trgt.onEnterFrame;			randomList = null;			textCount = 0;			end_textCount = null;			end_charMotion = null;			fixStr = null;			fixLength = 0;			str = null;		}	}}