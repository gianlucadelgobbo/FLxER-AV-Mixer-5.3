package {	import flash.display.Sprite;	import flash.display.Shape;	import flash.net.*;	import flash.events.*;    import flash.display.Graphics;	import flash.geom.Rectangle;	public class MapPoint extends Sprite{		var currentShape;		var myId;		var fnz;		var shape;		var handle;		var line;		var firstTime;		var getCurrentShape;		var deletePoint;		var getKeyboardSHIFT		var myCol		public function MapPoint(p:Array,a:uint,b:uint,col:String,f:Function,c:Boolean,i:Function,d:Function,k:Function) {			x = p[2];			y = p[3];			firstTime = false;			currentShape = a;			myId = b;			myCol = col;			fnz = f;			getCurrentShape = i;			deletePoint = d;			getKeyboardSHIFT = k;			shape = new Sprite();			handle = new Sprite();			handle.x = p[0]-p[2];			handle.y = p[1]-p[3];			line = new Sprite();			shape.buttonMode = true;			trace("MapPoint"+myId)			handle.buttonMode = true;			shape.graphics.beginFill("0x"+myCol,1);			shape.graphics.moveTo(-3,-3);			shape.graphics.lineTo(3,-3);			shape.graphics.lineTo(3,3);			shape.graphics.lineTo(-3,3);			shape.graphics.lineTo(-3,-3);            shape.graphics.endFill();			handle.graphics.beginFill("0x"+myCol,1);            handle.graphics.drawCircle(0, 0, 3);            handle.graphics.endFill();			shape.addEventListener(MouseEvent.MOUSE_DOWN, shapeMouseDown);			shape.addEventListener(MouseEvent.MOUSE_UP, stopDragShape);			shape.addEventListener(MouseEvent.MOUSE_OVER, overDragShape);			shape.addEventListener(MouseEvent.MOUSE_OUT, outDragShape);			handle.addEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown);			handle.addEventListener(MouseEvent.MOUSE_UP, stopDragHandle);			handle.addEventListener(MouseEvent.MOUSE_OVER, overDragShape);			handle.addEventListener(MouseEvent.MOUSE_OUT, outDragShape);			this.addChild(line);			this.addChild(shape);			this.addChild(handle);			if (c && myId) {				//handle.startDrag(true, new Rectangle(-p[2]-(FlxerDrawerPlugIn.w/2), -p[3]-(FlxerDrawerPlugIn.h/2), FlxerDrawerPlugIn.w,FlxerDrawerPlugIn.h));				handle.startDrag(true);				this.addEventListener(Event.ENTER_FRAME, updatePath);			}			if (handle.x+handle.y!=0) {				line.graphics.lineStyle(1, "0x"+myCol);				line.graphics.moveTo(0, 0);				line.graphics.lineTo(handle.x, handle.y);			}		}		private function handleMouseDown(event:Event):void {			trace("handleMouseDown "+getKeyboardSHIFT())			if (getKeyboardSHIFT()) {				deletePoint(currentShape,myId);			} else {				//handle.startDrag(true, new Rectangle(-x-(FlxerDrawerPlugIn.w/2), -y-(FlxerDrawerPlugIn.h/2), FlxerDrawerPlugIn.w,FlxerDrawerPlugIn.h));				handle.startDrag(true);				this.addEventListener(Event.ENTER_FRAME, updatePath);			}		}		public function stopDragHandle(event:Event):void {			if (myId != 0 || firstTime) {				trace("stopDragHandle"+event)				this.removeEventListener(Event.ENTER_FRAME, updatePath);				handle.stopDrag();				updatePath(event);				if (Math.abs(handle.x)<3 && Math.abs(handle.y)<3) {					this.removeChild(handle);					this.removeChild(line);				}			}			firstTime = true;			Preferences.pref.myAlt.stoppa();		}		public function overDragShape(event:Event):void {			trace("overDragShape "+getCurrentShape()+" - "+currentShape+" - "+getKeyboardSHIFT());			if (getKeyboardSHIFT()) {				Preferences.pref.myAlt.avvia("Delete");			} else if (myId == 0 && getCurrentShape()==currentShape) {				Preferences.pref.myAlt.avvia("Close shape");			}		}		public function outDragShape(event:Event):void {			Preferences.pref.myAlt.stoppa();			if (myId == 0) {			}		}		private function shapeMouseDown(event:Event):void {			trace("shapeMouseDown "+event)			if (getKeyboardSHIFT()) {				deletePoint(currentShape,myId)			} else {				//this.startDrag(true, new Rectangle(-x-(FlxerDrawerPlugIn.w/2), -y-(FlxerDrawerPlugIn.h/2), FlxerDrawerPlugIn.w,FlxerDrawerPlugIn.h));				this.startDrag(true);				this.addEventListener(Event.ENTER_FRAME, updatePath);			}		}		public function stopDragShape(event:Event):void {			trace("stopDragShape "+event)			this.removeEventListener(Event.ENTER_FRAME, updatePath);			this.stopDrag();			updatePath(event);		}		function updatePath(event:Event):void {            line.graphics.clear();			line.graphics.lineStyle(1, "0x"+myCol);			line.graphics.moveTo(0, 0);			line.graphics.lineTo(handle.x, handle.y);			trace("updatePath "+myId)			fnz(currentShape,myId, x+handle.x,y+handle.y, x, y);		}	}}