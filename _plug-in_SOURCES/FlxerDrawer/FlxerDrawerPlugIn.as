package {	import flash.display.Sprite;	import flash.display.Shape;	import flash.net.*;	import flash.events.*;    import flash.display.Graphics;	import flash.xml.XMLDocument;	import flash.xml.XMLNode;    import MapPoint;	import flash.ui.Keyboard;  	public class FlxerDrawerPlugIn extends Sprite {		var drawer_lc_receive;		//		var trgtEdit;		var drawArea,drawCnt;				var shapesAcnt,shapesA;		var handlesAcnt;		public var currentShape		var flxerDrawer_lc_controller;		var flxerDrawer_lc_plugin;		public static var w:uint;		public static var h:uint;		/* DEBUG */		var Plugin		/* DEBUG END */		var KeyboardSHIFT = false;		var myCol = "0000FF";		public function FlxerDrawerPlugIn() {			var ch = 0;			/*trace("getMovie "+Plugin.getMovie(ch));			trace("getChannel "+Plugin.getChannel(ch).parent.parent);			trace("getMask "+Plugin.getMask(ch));			trace("getCurrentChannel "+Plugin.getCurrentChannel());			trace("getMonWidth "+Plugin.getMonWidth());			trace("getMonHeight "+Plugin.getMonHeight());			*/			flxerDrawer_lc_controller = new LocalConnection();			flxerDrawer_lc_controller.client = this;			flxerDrawer_lc_plugin = new LocalConnection();            try {				flxerDrawer_lc_controller.connect("receive_from_controller");            } catch (error:ArgumentError) {                trace("Can't connect...the connection name is already being used by another SWF");            }			/* DEBUG			trgtEdit = this;			avvia(Plugin)  */			/* DEBUG END */			//shape.dragParent = true;		}		public function getKeyboardSHIFT():Boolean {			trace("KeyboardSHIFT "+KeyboardSHIFT)			return KeyboardSHIFT;		}		public function myOnKeyDown(event):void {			var myCode = event.keyCode;			trace("myOnKeyDown "+myCode)			switch (myCode) {				case Keyboard.SHIFT :				KeyboardSHIFT = true;				break;			}			trace("KeyboardSHIFT "+KeyboardSHIFT)		}		public function myOnKeyUp(event):void {			trace("myOnKeyUp "+event.keyCode)			switch (event.keyCode) {				case Keyboard.SHIFT :				KeyboardSHIFT = false;				break;			}		}		public function deletePoint(a,ii):void {			trace("deletePoint "+a+" "+ii)			//handlesAcnt[cc].removeChildAt(ii);			for (var b=0;b<shapesA[a].length;b++) {				trace("clearEditclearEditclearEditclearEditclearEditclearEdit")				if (trgtEdit.contains(drawArea)) handlesAcnt[a].removeChildAt(0);				shapesAcnt[a].graphics.clear();			}			//drawCnt.removeChild(shapesAcnt[cc]);			//drawCnt.removeChild(handlesAcnt[cc]);			//shapesAcnt[cc].splice(ii,1)			shapesA[a].splice(ii,1);			redrawMap(a);			stage.focus = stage;			//updateCurrent();		}		public function getCurrentShape():Number {			trace("getCurrentShape "+currentShape);			return currentShape;		}		public function avvia(p):void {			/* DEBUG */			Plugin = p			trgtEdit = Plugin.getMonitor();			/* DEBUG END */			w = Plugin.getMonWidth();			h = Plugin.getMonHeight();			trace("cazzo"+w)			trace("cazzo"+h)			if (trgtEdit.getChildByName("drawCnt")) {				drawCnt = trgtEdit.getChildByName("drawCnt")				drawArea = trgtEdit.getChildByName("drawArea")			} else {				drawArea = new Sprite();				drawArea.name = "drawArea";				drawArea.x = w/2;				drawArea.y = h/2;				var shape = new Sprite();				shape.graphics.beginFill(0xFFFFFF,0);				shape.graphics.moveTo(-w/2,-h/2);				shape.graphics.lineTo(w/2,-h/2);				shape.graphics.lineTo(w/2,h/2);				shape.graphics.lineTo(-w/2,h/2);				shape.graphics.lineTo(-w/2,-h/2);				shape.graphics.endFill();				drawArea.addChild(shape);				drawArea.addEventListener(MouseEvent.MOUSE_DOWN, myMouseDown);				drawArea.addEventListener(MouseEvent.MOUSE_UP, myMouseUp);				trgtEdit.addChild(drawArea);								//drawArea.mouseChildren = true;				//				drawCnt = new Sprite();				drawCnt.name = "drawCnt";				drawCnt.x = w/2;				drawCnt.y = h/2;				trgtEdit.addChild(drawCnt);				//			}			shapesA = new Array();			shapesAcnt = new Array();			handlesAcnt = new Array();		}		/* EDITING */		public function newShape():void {			trace("newShapennnnnnnnnnnn");			currentShape = undefined		}		public function setCol(c):void {			myCol = c;			clearAll()			drawMap()		}		public function clearAll():void {			for (var a=0;a<shapesA.length;a++) {				for (var b=0;b<shapesA[a].length;b++) {					trace("clearEditclearEditclearEditclearEditclearEditclearEdit")					if (trgtEdit.contains(drawArea)) handlesAcnt[a].removeChildAt(0);					shapesAcnt[a].graphics.clear();				}			}			shapesAcnt = new Array();			handlesAcnt = new Array();			currentShape = undefined		}		public function clearEdit():void {			clearAll();			shapesA = new Array();			trace("clearEditnnnnnnnnnn");		}		public function saveShapes():void {			trace("saveShapesnnnnnnnnnn");			var xmlTmp = "<g>\n";			for (var a=0;a<shapesA.length;a++) {				xmlTmp+="	<path fill='#000000' stroke='none' d='M"+shapesA[a][0][2]+","+shapesA[a][0][3];				for (var b=1;b<shapesA[a].length;b++) {					trace("gggg "+a+" "+b)					xmlTmp+="Q"+shapesA[a][b][0];					xmlTmp+=","+shapesA[a][b][1];					xmlTmp+=","+shapesA[a][b][2];					xmlTmp+=","+shapesA[a][b][3];				}				xmlTmp+="Q"+shapesA[a][0][0];				xmlTmp+=","+shapesA[a][0][1];				xmlTmp+=","+shapesA[a][0][2];				xmlTmp+=","+shapesA[a][0][3];				xmlTmp+="' />\n";			}			xmlTmp+="</g>\n";			flxerDrawer_lc_plugin.send("receive_from_plugin", "saveShapesAct", xmlTmp);		}		private function myMouseDown(event:Event):void {			//drawArea.removeEventListener(MouseEvent.MOUSE_DOWN, myMouseDown);			trace("cazzocazzocazzo2 "+shapesA.length)			if (currentShape == undefined) {				shapesA.push(new Array());				currentShape = shapesA.length-1;				//				shapesAcnt.push(new Sprite());				handlesAcnt.push(new Sprite());				drawArea.addChild(shapesAcnt[currentShape]);				drawCnt.addChild(handlesAcnt[currentShape]);				/*if (!Preferences.pref.flxerDrawedMasks.data.lista) {					Preferences.pref.flxerDrawedMasks.data.lista = new Array();				}*/			}			trace("cazzocazzocazzo3 "+currentShape);			var p = new Array(drawCnt.mouseX,drawCnt.mouseY,drawCnt.mouseX,drawCnt.mouseY);			shapesA[currentShape].push(p);			handlesAcnt[currentShape].addChildAt(new MapPoint(p,currentShape,shapesA[currentShape].length-1, myCol, updatePath, true, getCurrentShape,deletePoint,getKeyboardSHIFT),shapesA[currentShape].length-1);			updateCurrent();		}		private function updatePath(shape,id,a,b,c,d) {			currentShape = shape;			trace("shape "+shape)			trace("id "+id)			shapesA[shape][id][0] = a;			shapesA[shape][id][1] = b;			shapesA[shape][id][2] = c;			shapesA[shape][id][3] = d;			updateCurrent();			if (id==0) {				currentShape = undefined;				stage.focus = stage;			}		}		/**/		private function myMouseUp(event:Event):void {			drawArea.addEventListener(MouseEvent.MOUSE_DOWN, myMouseDown);		}		public function getMonWidth() {			return Plugin.getMonWidth();		}		public function getMonHeight() {			return Plugin.getMonHeight();		}		public function setUseMap() {			if (trgtEdit.contains(drawArea)) trgtEdit.removeChild(drawArea);			if (trgtEdit.contains(drawCnt)) trgtEdit.removeChild(drawCnt);		}		public function setEditMap() {			trace("editMapeditMapeditMapeditMapeditMapeditMap")			if (!trgtEdit.contains(drawArea)) trgtEdit.addChild(drawArea);			if (!trgtEdit.contains(drawCnt)) trgtEdit.addChild(drawCnt);		}		public function editMap(str) {			setEditMap();			clearAll();			var xmlMap:XMLDocument = new XMLDocument();			xmlMap.ignoreWhite = true;			xmlMap.parseXML(str);			for (var a=0;a<xmlMap.childNodes[0].childNodes[0].childNodes.length;a++) {				shapesA[a] = new Array();				handlesAcnt.push(new Sprite());				drawCnt.addChild(handlesAcnt[a]);				var forma = xmlMap.childNodes[0].childNodes[0].childNodes[a].attributes.d.substring(1).split("Q");				for (var b=0;b<forma.length;b++) {					forma[b] = forma[b].split(",");					trace(a+"-"+b+" "+forma[b][0]+" "+forma[b][1]+" "+forma[b][2]+" "+forma[b][3])					var punto = new Array((forma[b][2] ? forma[b][2] : forma[b][0]),(forma[b][3] ? forma[b][3] : forma[b][1]),forma[b][0],forma[b][1])					var tt = new MapPoint(punto,a,b, myCol, updatePath, false,getCurrentShape,deletePoint,getKeyboardSHIFT)					handlesAcnt[a].addChildAt(tt,b);					shapesA[a].push(punto);				}				currentShape = a;				updateCurrent()			}		}		public function drawMap() {			setEditMap();			for (var a=0;a<shapesA.length;a++) {				redrawMap(a);			}		}		public function redrawMap(a) {			handlesAcnt.push(new Sprite());			drawCnt.addChild(handlesAcnt[a]);			for (var b=0;b<shapesA[a].length;b++) {				var tt = new MapPoint(shapesA[a][b],a,b, myCol, updatePath, false,getCurrentShape,deletePoint,getKeyboardSHIFT)				handlesAcnt[a].addChildAt(tt,b);			}			currentShape = a;			updateCurrent()		}		function updateCurrent() {			trace("updateCurrent"+currentShape)			if (shapesAcnt[currentShape] is Shape) {				shapesAcnt[currentShape].graphics.clear();			} else {				shapesAcnt[currentShape] = new Shape();			}			shapesAcnt[currentShape].graphics.beginFill("0x"+myCol,.5);			shapesAcnt[currentShape].graphics.moveTo(shapesA[currentShape][0][2], shapesA[currentShape][0][3]);			for (var a=1;a<shapesA[currentShape].length;a++) {				shapesAcnt[currentShape].graphics.curveTo(shapesA[currentShape][a][0], shapesA[currentShape][a][1], shapesA[currentShape][a][2], shapesA[currentShape][a][3]);			}			shapesAcnt[currentShape].graphics.curveTo(shapesA[currentShape][0][0], shapesA[currentShape][0][1], shapesA[currentShape][0][2], shapesA[currentShape][0][3]);			shapesAcnt[currentShape].graphics.endFill();			drawArea.addChild(shapesAcnt[currentShape]); 		}	}}